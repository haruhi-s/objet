;; TODO
;; test dynamic scoped variables
;; labels, let*
;; eval&
;; defun
;; separate closure variables and *env*

(defvar *meta-lvl* 0)

(defvar *env* `((t . t)
                (get-meta-lvl . ,(lambda (k) (funcall (car k) *meta-lvl*)))
                ,@(mapcar
                   (lambda (x) (cons x (lambda (k &rest args) (funcall (car k) (apply x args)))))
                   '(+ - * / cons car cdr caar cadr cdar cddr caaar caadr cadar caddr cdaar cdadr cddar cdddr caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr eq list list* read not prin1 print write-string rplaca rplacd terpri concatenate remove-if-not))
                (funcall . ,(lambda (k f &rest args) (apply& f args k)))
                (call/cc . ,(lambda (k f) (apply& f (list (lambda (_ v) (funcall (car k) v)))
                                                  (list (lambda (v) v) (cadr k)))))
                (eval . ,(lambda (k form) (eval& form () k)))
                (eval-in-host . ,(lambda (k x) (funcall (car k) (eval x))))
                (repl . ,(lambda (k)
                           (let ((*meta-lvl* (1+ *meta-lvl*)))
                             (eval& '(loop (write-string "bobject> ")
                                      (if (eq (let ((v (prin1 (eval (read))))) (terpri) v) 'quit) 'loop))
                                    *env* k))))))

(defun map& (f list k)
  (if (consp list)
      (funcall f
               (list (lambda (head)
                       (map& f (cdr list)
                             (list (lambda (tail) (funcall (car k) (cons head tail)))
                                   (cadr k))))
                     (cadr k))
               (car list))
      (funcall (car k) nil)))

(defun apply& (f args k)
  (if (consp f) ; (closure env args body)
      (let ((bound `(,@(mapcar #'cons (caddr f) args) ,@(cadr f))))
        (map& (lambda (k form) (eval& k bound form)) (cdddr f)
              (list (lambda (v) (funcall (car k) (car (last v))))
                    (cadr k))))
      (apply f k args)))

(defun eval& (k env form)
  (labels ((eval-with-env& (k form) (eval& k env form))
           (eval-quasi& (k form)
             (cond ((sb-int:comma-p form) (eval& k env (sb-int:comma-expr form)))
                   ((consp form) (map& #'eval-quasi& form k))
                   (t (funcall (car k) form))))
           (eval-list& (k env form)
             (map& (lambda (k form) (eval& k env form)) form
                   (list (lambda (v) (funcall (car k) (car (last v))))
                         (cadr k)))))
    (cond
      ((symbolp form) (funcall (car k) (cdr (assoc (print form) (print (append env (cadr k) *env*))))))
      ((consp form)
       (cond
         ((and (symbolp (car form)) (assoc (car form) (append env (cadr k) *env*)))
          (eval& (list (lambda (f) (map& #'eval-with-env&
                                         (cdr form)
                                         (list (lambda (args) (apply& f args k))
                                               (cadr k))))
                       (cadr k))
                 env (car form)))
         ((eq (car form) 'lambda) (funcall (car k) `(closure ,env ,@(cdr form))))
         ((eq (car form) 'closure) (funcall (car k) form))
         ((eq (car form) 'quote) (funcall (car k) (cadr form)))
         ((eq (car form) 'sb-int:quasiquote) (eval-quasi& k (cadr form)))
         ((eq (car form) 'defvar) (eval& (list (lambda (v)
                                                 (setf (cadr k) (cons (cons (cadr form) v) (cadr k))) ; TODO
                                                 (funcall (car k) nil))
                                               (cadr k))
                                         env (caddr form)))
         ((eq (car form) 'define) (eval& (list (lambda (v)
                                                 (setf *env* (cons (cons (cadr form) v) *env*))
                                                 (funcall (car k) nil))
                                               (cadr k))
                                         env (caddr form)))
         ((eq (car form) 'set!) (eval& (list (lambda (v)
                                               (rplacd (assoc (cadr form) (append env (cadr k) *env*)) v)
                                               (funcall (car k) v))
                                             (cadr k))
                                       env (caddr form)))
         ((eq (car form) 'progn) (eval-list& k env (cdr form)))
         ((eq (car form) 'let)
          (map& (lambda (k binding) (eval& (list (lambda (v) (funcall (car k) (cons (car binding) v)))
                                                 (cadr k))
                                           env (cadr binding)))
                (cadr form)
                (list (lambda (q)
                        (let ((dyn (remove-if-not (lambda (x) (assoc (car x) (cadr k))) q))
                              (lex (remove-if-not (lambda (x) (not (assoc (car x) (cadr k)))) q)))
                          (eval-list& (list (car k) (append dyn (cadr k)))
                                      (append lex env)
                                      (cddr form))))
                      (cadr k))))
         ((eq (car form) 'loop)
          (labels ((l (k) (eval& (list (lambda (v) (if (eq 'loop v) (funcall (car k) v) (l k)))
                                       (cadr k))
                                 env (cdr form))))
            (l k)))
         ((eq (car form) 'if) (eval-with-env&
                               (list (lambda (b) (eval-with-env& k (if b (caddr form) (cadddr form))))
                                     (cadr k))
                               (cadr form)))
         (t (eval-with-env& (list (lambda (f)
                                    (map& #'eval-with-env& (cdr form)
                                          (list (lambda (args)
                                                  (apply& f args k))
                                                (cadr k))))
                                  (cadr k))
                            (car form)))))
      (t (funcall (car k) form)))))

(defun toy-eval (form)
  (let ((result nil))
    (eval& (list (lambda (v) (setq result v)) ()) () form)
    result))

(defun repl ()
  (labels ((l ()
             (write-string "
object> ")  (eval& (read) nil (list (lambda (v) (if (eq v 'quit) 'quit (progn (prin1 v) (l))))
                                    nil))))
    (l)))

;; (loop
;;   (write-string "bobject> ")
;;   (if (eq (let ((v (prin1 (eval (read))))) (terpri) v) 'quit) 'loop))
